#!/bin/bash

# Generated by perl modules
# App::Spec v0.012
# App::Spec::Bash v0.000
# mydemo - Demo

declare OP=
declare -a ERRORS=()
declare -a COMMANDS=()
declare stdout_terminal=false stderr_terminal=false
declare APPSPEC_COLOR_BOLD='\x1b[1m'
declare APPSPEC_COLOR_RED='\x1b[31m'
declare APPSPEC_COLOR_ERROR="$GIT_HUB_COLOR_RED$GIT_HUB_COLOR_BOLD"
declare APPSPEC_COLOR_GREEN='\x1b[32m'
declare APPSPEC_COLOR_CYAN='\x1b[36m'
declare APPSPEC_COLOR_MAGENTA='\x1b[35m'
declare APPSPEC_COLOR_YELLOW='\x1b[33m'
declare APPSPEC_COLOR_DARKGRAY='\x1b[90m'
declare APPSPEC_NO_COLOR='\x1b[0m'



DEBUG=false
[[ -n "$APPSPEC_BASH_DEBUG" ]] && DEBUG=true

APPSPEC.run() {
  APPSPEC.init-terminal
  APPSPEC.parse $@
}

APPSPEC.run-op() {
  if (( ${#ERRORS[*]} > 0 )); then
    APPSPEC.show_help
    APPSPEC.error "${ERRORS[*]}"
    exit 1
  else
    debug "OP: $OP"
  fi
  if [[ -n "$OP" ]]; then
    MyDemo.$OP
  else
    echo "No operation found"
  fi
}

APPSPEC.parse() {
  local argv=($@)
  debug "ARGV: ${argv[*]}"
      declare OPT_VERSION=false
      declare OPT_HELP=false

  if [[ ${#argv[@]} -eq 0 ]]; then
      APPSPEC.add-error "missing subcommand"
      APPSPEC.run-op
      return
  fi
  while [[ ${#argv[@]} > 0 ]]; do
    debug "processing ${argv[0]}..."
    case "${argv[0]}" in
    --version)
        debug "LONG OPTION version"
        OPT_VERSION=true
        shift_arg

    ;;
    --help)
        debug "LONG OPTION help"
        OPT_HELP=true
        shift_arg

    ;;
    --) shift_arg; break
    ;;
    --*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break
    ;;

    -*)
      local i arg=${argv[0]/-/}
      for (( i=0; i < "${#arg}"; i++ )); do
        local char="${arg:$i:1}"
        value="${arg:$i+1}"
        if (( $i+1 == ${#arg} )); then
          shift_arg
          value="${argv[0]}"
        fi
        debug "processing short $char. arg=$arg value=$value"
        case "$char" in
        V)
          debug "SHORT OPTION version"
          OPT_VERSION=true

        ;;
        h)
          debug "SHORT OPTION help"
          OPT_HELP=true

        ;;
        *)
          APPSPEC.add-error "unknown option -$char"
          shift_arg
          break
        ;;
        esac
      done

    ;;

    # SUBCOMMANDS
    help)
      debug "COMMAND help"
      COMMANDS+=("help")
      declare OPT_ALL=false

      shift_arg
      APPSPEC.parse-help
      if [[ -z "$OP" ]]; then
        OP=cmd_help
        APPSPEC.run-op
      fi

      return
    ;;
    nested1)
      debug "COMMAND nested1"
      COMMANDS+=("nested1")

      shift_arg
      APPSPEC.parse-nested1
      if [[ -z "$OP" ]]; then
        OP=nested1
        APPSPEC.run-op
      fi

      return
    ;;
    service)
      debug "COMMAND service"
      COMMANDS+=("service")

      shift_arg
      APPSPEC.parse-service
      if [[ -z "$OP" ]]; then
        APPSPEC.add-error "missing subcommand"
        APPSPEC.run-op
      fi

      return
    ;;
    test1)
      debug "COMMAND test1"
      COMMANDS+=("test1")
      declare OPT_FLAG_A=false
      declare OPT_FLAG_B=false
      declare -i OPT_FLAG_C=0
      declare OPT_TEST_D=
      declare OPT_TEST_E=
      declare -a OPT_TEST_F=()
      declare OPT_TEST_G=

      shift_arg
      APPSPEC.parse-test1
      if [[ -z "$OP" ]]; then
        OP=test1
        APPSPEC.run-op
      fi

      return
    ;;
    *)
      APPSPEC.add-error "unknown subcommand ${argv[0]}"
      shift_arg
      APPSPEC.run-op
      return
    ;;


    esac
  done

  debug "ARGV: ${argv[*]}"
}

APPSPEC.parse-help-nested1-nested2() {
  [[ ${#argv[@]} -eq 0 ]] && return

  while [[ ${#argv[@]} -gt 0 ]]; do
    case "${argv[0]}" in
    --) shift_arg; break
    ;;
    --*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break
    ;;

    -*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break

    ;;

    # SUBCOMMANDS
    *)
      debug "end of options and subcommands"
      shift_arg
      return
    ;;


    esac
  done

}

APPSPEC.parse-help-nested1() {
  [[ ${#argv[@]} -eq 0 ]] && return

  while [[ ${#argv[@]} -gt 0 ]]; do
    case "${argv[0]}" in
    --) shift_arg; break
    ;;
    --*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break
    ;;

    -*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break

    ;;

    # SUBCOMMANDS
    nested2)
      debug "COMMAND nested2"
      COMMANDS+=("nested2")

      shift_arg
      APPSPEC.parse-help-nested1-nested2

      return
    ;;
    *)
      APPSPEC.add-error "unknown subcommand ${argv[0]}"
      shift_arg
      APPSPEC.run-op
      return
    ;;


    esac
  done

}

APPSPEC.parse-help-service-list() {
  [[ ${#argv[@]} -eq 0 ]] && return

  while [[ ${#argv[@]} -gt 0 ]]; do
    case "${argv[0]}" in
    --) shift_arg; break
    ;;
    --*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break
    ;;

    -*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break

    ;;

    # SUBCOMMANDS
    *)
      debug "end of options and subcommands"
      shift_arg
      return
    ;;


    esac
  done

}

APPSPEC.parse-help-service-start() {
  [[ ${#argv[@]} -eq 0 ]] && return

  while [[ ${#argv[@]} -gt 0 ]]; do
    case "${argv[0]}" in
    --) shift_arg; break
    ;;
    --*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break
    ;;

    -*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break

    ;;

    # SUBCOMMANDS
    *)
      debug "end of options and subcommands"
      shift_arg
      return
    ;;


    esac
  done

}

APPSPEC.parse-help-service-status() {
  [[ ${#argv[@]} -eq 0 ]] && return

  while [[ ${#argv[@]} -gt 0 ]]; do
    case "${argv[0]}" in
    --) shift_arg; break
    ;;
    --*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break
    ;;

    -*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break

    ;;

    # SUBCOMMANDS
    *)
      debug "end of options and subcommands"
      shift_arg
      return
    ;;


    esac
  done

}

APPSPEC.parse-help-service-stop() {
  [[ ${#argv[@]} -eq 0 ]] && return

  while [[ ${#argv[@]} -gt 0 ]]; do
    case "${argv[0]}" in
    --) shift_arg; break
    ;;
    --*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break
    ;;

    -*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break

    ;;

    # SUBCOMMANDS
    *)
      debug "end of options and subcommands"
      shift_arg
      return
    ;;


    esac
  done

}

APPSPEC.parse-help-service() {
  [[ ${#argv[@]} -eq 0 ]] && return

  while [[ ${#argv[@]} -gt 0 ]]; do
    case "${argv[0]}" in
    --) shift_arg; break
    ;;
    --*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break
    ;;

    -*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break

    ;;

    # SUBCOMMANDS
    list)
      debug "COMMAND list"
      COMMANDS+=("list")

      shift_arg
      APPSPEC.parse-help-service-list

      return
    ;;
    start)
      debug "COMMAND start"
      COMMANDS+=("start")

      shift_arg
      APPSPEC.parse-help-service-start

      return
    ;;
    status)
      debug "COMMAND status"
      COMMANDS+=("status")

      shift_arg
      APPSPEC.parse-help-service-status

      return
    ;;
    stop)
      debug "COMMAND stop"
      COMMANDS+=("stop")

      shift_arg
      APPSPEC.parse-help-service-stop

      return
    ;;
    *)
      APPSPEC.add-error "unknown subcommand ${argv[0]}"
      shift_arg
      APPSPEC.run-op
      return
    ;;


    esac
  done

}

APPSPEC.parse-help-test1() {
  [[ ${#argv[@]} -eq 0 ]] && return

  while [[ ${#argv[@]} -gt 0 ]]; do
    case "${argv[0]}" in
    --) shift_arg; break
    ;;
    --*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break
    ;;

    -*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break

    ;;

    # SUBCOMMANDS
    *)
      debug "end of options and subcommands"
      shift_arg
      return
    ;;


    esac
  done

}

APPSPEC.parse-help() {
  [[ ${#argv[@]} -eq 0 ]] && return

  while [[ ${#argv[@]} -gt 0 ]]; do
    case "${argv[0]}" in
    --all)
        debug "LONG OPTION all"
        OPT_ALL=true
        shift_arg

    ;;
    --) shift_arg; break
    ;;
    --*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break
    ;;

    -*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break

    ;;

    # SUBCOMMANDS
    nested1)
      debug "COMMAND nested1"
      COMMANDS+=("nested1")

      shift_arg
      APPSPEC.parse-help-nested1

      return
    ;;
    service)
      debug "COMMAND service"
      COMMANDS+=("service")

      shift_arg
      APPSPEC.parse-help-service

      return
    ;;
    test1)
      debug "COMMAND test1"
      COMMANDS+=("test1")

      shift_arg
      APPSPEC.parse-help-test1

      return
    ;;
    *)
      APPSPEC.add-error "unknown subcommand ${argv[0]}"
      shift_arg
      APPSPEC.run-op
      return
    ;;


    esac
  done

}

APPSPEC.parse-nested1-nested2() {
  [[ ${#argv[@]} -eq 0 ]] && return

  while [[ ${#argv[@]} -gt 0 ]]; do
    case "${argv[0]}" in
    --) shift_arg; break
    ;;
    --*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break
    ;;

    -*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break

    ;;

    # SUBCOMMANDS
    *)
      debug "end of options and subcommands"
      shift_arg
      return
    ;;


    esac
  done

}

APPSPEC.parse-nested1() {
  [[ ${#argv[@]} -eq 0 ]] && return

  while [[ ${#argv[@]} -gt 0 ]]; do
    case "${argv[0]}" in
    --) shift_arg; break
    ;;
    --*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break
    ;;

    -*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break

    ;;

    # SUBCOMMANDS
    nested2)
      debug "COMMAND nested2"
      COMMANDS+=("nested2")

      shift_arg
      APPSPEC.parse-nested1-nested2
      if [[ -z "$OP" ]]; then
        OP=nested2
        APPSPEC.run-op
      fi

      return
    ;;
    *)
      APPSPEC.add-error "unknown subcommand ${argv[0]}"
      shift_arg
      APPSPEC.run-op
      return
    ;;


    esac
  done

}

APPSPEC.parse-service-list() {
  [[ ${#argv[@]} -eq 0 ]] && return

  while [[ ${#argv[@]} -gt 0 ]]; do
    case "${argv[0]}" in
    --) shift_arg; break
    ;;
    --*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break
    ;;

    -*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break

    ;;

    # SUBCOMMANDS
    *)
      debug "end of options and subcommands"
      shift_arg
      return
    ;;


    esac
  done

}

APPSPEC.parse-service-start() {
  [[ ${#argv[@]} -eq 0 ]] && return

  while [[ ${#argv[@]} -gt 0 ]]; do
    case "${argv[0]}" in
    --) shift_arg; break
    ;;
    --*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break
    ;;

    -*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break

    ;;

    # SUBCOMMANDS
    *)
      debug "end of options and subcommands"
      shift_arg
      return
    ;;


    esac
  done

}

APPSPEC.parse-service-status() {
  [[ ${#argv[@]} -eq 0 ]] && return

  while [[ ${#argv[@]} -gt 0 ]]; do
    case "${argv[0]}" in
    --) shift_arg; break
    ;;
    --*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break
    ;;

    -*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break

    ;;

    # SUBCOMMANDS
    *)
      debug "end of options and subcommands"
      shift_arg
      return
    ;;


    esac
  done

}

APPSPEC.parse-service-stop() {
  [[ ${#argv[@]} -eq 0 ]] && return

  while [[ ${#argv[@]} -gt 0 ]]; do
    case "${argv[0]}" in
    --) shift_arg; break
    ;;
    --*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break
    ;;

    -*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break

    ;;

    # SUBCOMMANDS
    *)
      debug "end of options and subcommands"
      shift_arg
      return
    ;;


    esac
  done

}

APPSPEC.parse-service() {
  [[ ${#argv[@]} -eq 0 ]] && return

  while [[ ${#argv[@]} -gt 0 ]]; do
    case "${argv[0]}" in
    --) shift_arg; break
    ;;
    --*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break
    ;;

    -*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break

    ;;

    # SUBCOMMANDS
    list)
      debug "COMMAND list"
      COMMANDS+=("list")

      shift_arg
      APPSPEC.parse-service-list
      if [[ -z "$OP" ]]; then
        OP=list
        APPSPEC.run-op
      fi

      return
    ;;
    start)
      debug "COMMAND start"
      COMMANDS+=("start")

      shift_arg
      APPSPEC.parse-service-start
      if [[ -z "$OP" ]]; then
        OP=start
        APPSPEC.run-op
      fi

      return
    ;;
    status)
      debug "COMMAND status"
      COMMANDS+=("status")

      shift_arg
      APPSPEC.parse-service-status
      if [[ -z "$OP" ]]; then
        OP=status
        APPSPEC.run-op
      fi

      return
    ;;
    stop)
      debug "COMMAND stop"
      COMMANDS+=("stop")

      shift_arg
      APPSPEC.parse-service-stop
      if [[ -z "$OP" ]]; then
        OP=stop
        APPSPEC.run-op
      fi

      return
    ;;
    *)
      APPSPEC.add-error "unknown subcommand ${argv[0]}"
      shift_arg
      APPSPEC.run-op
      return
    ;;


    esac
  done

}

APPSPEC.parse-test1() {
  [[ ${#argv[@]} -eq 0 ]] && return

  while [[ ${#argv[@]} -gt 0 ]]; do
    case "${argv[0]}" in
    --flag-a)
        debug "LONG OPTION flag-a"
        OPT_FLAG_A=true
        shift_arg

    ;;
    --flag-b)
        debug "LONG OPTION flag-b"
        OPT_FLAG_B=true
        shift_arg

    ;;
    --flag-c)
        debug "LONG OPTION flag-c"
        OPT_FLAG_C+=1
        shift_arg

    ;;
    --test-d)
        debug "LONG OPTION test-d"
        shift_arg
        OPT_TEST_D="${argv[0]}"
        shift_arg

    ;;
    --test-e)
        debug "LONG OPTION test-e"
        shift_arg
        OPT_TEST_E="${argv[0]}"
        shift_arg

    ;;
    --test-f)
        debug "LONG OPTION test-f"
        shift_arg
        OPT_TEST_F+=("${argv[0]}")
        shift_arg

    ;;
    --test-g)
        debug "LONG OPTION test-g"
        shift_arg
        OPT_TEST_G="${argv[0]}"
        shift_arg

    ;;
    --) shift_arg; break
    ;;
    --*)
        APPSPEC.add-error "unknown option ${argv[0]}"
        shift_arg
        break
    ;;

    -*)
      local i arg=${argv[0]/-/}
      for (( i=0; i < "${#arg}"; i++ )); do
        local char="${arg:$i:1}"
        value="${arg:$i+1}"
        if (( $i+1 == ${#arg} )); then
          shift_arg
          value="${argv[0]}"
        fi
        debug "processing short $char. arg=$arg value=$value"
        case "$char" in
        a)
          debug "SHORT OPTION flag-a"
          OPT_FLAG_A=true

        ;;
        b)
          debug "SHORT OPTION flag-b"
          OPT_FLAG_B=true

        ;;
        c)
          debug "SHORT OPTION flag-c"
          OPT_FLAG_C+=1

        ;;
        d)
          debug "SHORT OPTION test-d"
          OPT_TEST_D="$value"
          shift_arg
          break

        ;;
        e)
          debug "SHORT OPTION test-e"
          OPT_TEST_E="$value"
          shift_arg
          break

        ;;
        f)
          debug "SHORT OPTION test-f"
          OPT_TEST_F+=("$value")
          shift_arg
          break

        ;;
        g)
          debug "SHORT OPTION test-g"
          OPT_TEST_G="$value"
          shift_arg
          break

        ;;
        *)
          APPSPEC.add-error "unknown option -$char"
          shift_arg
          break
        ;;
        esac
      done

    ;;

    # SUBCOMMANDS
    *)
      debug "end of options and subcommands"
      shift_arg
      return
    ;;


    esac
  done

}




APPSPEC.colored() {
    local fh="$1"
    local message="$2"
    if [[ "$fh" == "stdout" ]] && ! $stdout_terminal; then
        echo "$message"
        return
    fi
    if [[ "$fh" == stderr ]] && ! $stderr_terminal; then
        echo "$message"
        return
    fi
    shift
    shift
    local colornames=($@)
    local varname value colored=

    for i in ${colornames[@]}; do
        varname="APPSPEC_COLOR_$i"
        value="${!varname}"
        colored+="$value"
    done

    colored+="$message"
    colored+="$APPSPEC_NO_COLOR"
    echo "$colored"

}

APPSPEC.colorize() {
    local fh="$1"
    local message="$2"
    shift
    shift
    [[ "$fh" == stdout ]] && echo -e "$(APPSPEC.colored "$fh" "$message" $@)"
    [[ "$fh" == stderr ]] && echo -e "$(APPSPEC.colored "$fh" "$message" $@)" >&2
}

APPSPEC.say() {
    local message="$1"
    shift
    if [[ $# -gt 0 ]]; then
        echo -e "$(APPSPEC.colored stdout "$message" $@)"
    else
        echo "$message"
    fi
}

APPSPEC.error() {
    local message="$1"
    echo -e "$(APPSPEC.colored stderr "$message" BOLD RED)" >&2
}

APPSPEC.add-error() {
    debug "$1"
    ERRORS+=("$1")
}

APPSPEC.init-terminal() {
  if [[ -t 1 ]]; then
    stdout_terminal=true
  fi
  if [[ -t 2 ]]; then
    stderr_terminal=true
  fi
}


APPSPEC.cmd_help() {
  debug "======== APPSPEC.cmd_help"
  COMMANDS=("${COMMANDS[@]:1}")
  APPSPEC.show_help
}

APPSPEC.show_help() {
  source "$APPSPECDIR/lib/help"
  debug "======== APPSPEC.show_help"
  if [[ -n "$COMMANDS" ]]; then
    local func="${COMMANDS[*]}"
    func="${func/ /-}"
    debug "func $func"
    APPSPEC.help-$func
  else
    APPSPEC.help-ROOT
  fi
}

shift_arg() {
    argv=("${argv[@]:1}")
}

debug() {
  $DEBUG && APPSPEC.colorize stderr "$@" DARKGRAY
}
