#!/bin/bash

# Generated by perl modules
# App::Spec v0.010
# App::Spec::Bash v0.000
# mydemo - Demo

declare OP=
declare -a ERRORS=()
declare -a COMMANDS=()

DEBUG=false
[[ -n "$APPSPEC_BASH_DEBUG" ]] && DEBUG=true

APPSPEC.run() {
  APPSPEC.parse $@
}

APPSPEC.run-op() {
  if (( ${#ERRORS[*]} > 0 )); then
    echo "ERRORS: (${ERRORS[*]})" >&2
    exit 1
  else
    debug "OP: $OP"
  fi
  if [[ -n "$OP" ]]; then
    MyDemo.$OP
  else
    echo "No operation found"
  fi
}

APPSPEC.parse() {
  local argv=($@)
  debug "ARGV: ${argv[*]}"
      declare OPT_VERSION=false
      declare OPT_HELP=false

  while [[ ${#argv} > 0 ]]; do
    debug "processing ${argv[0]}..."
    case "${argv[0]}" in
    --version)
        debug "LONG OPTION version"
        OPT_VERSION=true
        shift_arg

    ;;
    --help)
        debug "LONG OPTION help"
        OPT_HELP=true
        shift_arg

    ;;
    --*)
        debug "!UNKNOWN OPTION ${argv[0]}"
        ERRORS+=("unknown option ${argv[0]}")
        shift_arg
        break
    ;;

    -*)
      local i arg=${argv[0]/-/}
      for (( i=0; i < "${#arg}"; i++ )); do
        local char="${arg:$i:1}"
        value="${arg:$i+1}"
        if (( $i+1 == ${#arg} )); then
          shift_arg
          value="${argv[0]}"
        fi
        debug "processing short $char. arg=$arg value=$value"
        case "$char" in
        V)
          debug "SHORT OPTION version"
          OPT_VERSION=true

        ;;
        h)
          debug "SHORT OPTION help"
          OPT_HELP=true

        ;;
        *)
          debug "!UNKNOWN option -$char"
          ERRORS+=("unknown option -$char")
          shift_arg
          break
        ;;
        esac
      done

    ;;

    # SUBCOMMANDS
    help)
      debug COMMAND help
      COMMANDS+=("help")
      declare OPT_ALL=false

      shift_arg
      APPSPEC.parse-help
                if [[ -z "$OP" ]]; then
                  OP=cmd_help
                  APPSPEC.run-op
                fi

      return
    ;;
    nested1)
      debug COMMAND nested1
      COMMANDS+=("nested1")

      shift_arg
      APPSPEC.parse-nested1
                if [[ -z "$OP" ]]; then
                  OP=nested1
                  APPSPEC.run-op
                fi

      return
    ;;
    test1)
      debug COMMAND test1
      COMMANDS+=("test1")
      declare OPT_FLAG_A=false
      declare OPT_FLAG_B=false
      declare -i OPT_FLAG_C=0
      declare OPT_TEST_D=
      declare OPT_TEST_E=
      declare -a OPT_TEST_F=()
      declare OPT_TEST_G=

      shift_arg
      APPSPEC.parse-test1
                if [[ -z "$OP" ]]; then
                  OP=test1
                  APPSPEC.run-op
                fi

      return
    ;;
    *)
      debug "UNKNOWN cmd ${argv[0]}"
      ERRORS+=("unknown subcommand ${argv[0]}")
      shift_arg
      return
    ;;


    esac
  done

  debug "ARGV: ${argv[*]}"
}

APPSPEC.parse-help-nested1-nested2() {
  while [[ ${#argv} > 0 ]]; do
    case "${argv[0]}" in

    -*)

    ;;

    # SUBCOMMANDS
    *)
      debug "UNKNOWN cmd ${argv[0]}"
      ERRORS+=("unknown subcommand ${argv[0]}")
      shift_arg
      return
    ;;


    esac
  done

}

APPSPEC.parse-help-nested1() {
  while [[ ${#argv} > 0 ]]; do
    case "${argv[0]}" in

    -*)

    ;;

    # SUBCOMMANDS
    nested2)
      debug COMMAND nested2
      COMMANDS+=("nested2")

      shift_arg
      APPSPEC.parse-help-nested1-nested2

      return
    ;;
    *)
      debug "UNKNOWN cmd ${argv[0]}"
      ERRORS+=("unknown subcommand ${argv[0]}")
      shift_arg
      return
    ;;


    esac
  done

}

APPSPEC.parse-help-test1() {
  while [[ ${#argv} > 0 ]]; do
    case "${argv[0]}" in

    -*)

    ;;

    # SUBCOMMANDS
    *)
      debug "UNKNOWN cmd ${argv[0]}"
      ERRORS+=("unknown subcommand ${argv[0]}")
      shift_arg
      return
    ;;


    esac
  done

}

APPSPEC.parse-help() {
  while [[ ${#argv} > 0 ]]; do
    case "${argv[0]}" in
    --all)
        debug "LONG OPTION all"
        OPT_ALL=true
        shift_arg

    ;;
    --*)
        debug "!UNKNOWN OPTION ${argv[0]}"
        ERRORS+=("unknown option ${argv[0]}")
        shift_arg
        break
    ;;

    -*)
      local i arg=${argv[0]/-/}
      for (( i=0; i < "${#arg}"; i++ )); do
        local char="${arg:$i:1}"
        value="${arg:$i+1}"
        if (( $i+1 == ${#arg} )); then
          shift_arg
          value="${argv[0]}"
        fi
        debug "processing short $char. arg=$arg value=$value"
        case "$char" in
        *)
          debug "!UNKNOWN option -$char"
          ERRORS+=("unknown option -$char")
          shift_arg
          break
        ;;
        esac
      done

    ;;

    # SUBCOMMANDS
    nested1)
      debug COMMAND nested1
      COMMANDS+=("nested1")

      shift_arg
      APPSPEC.parse-help-nested1

      return
    ;;
    test1)
      debug COMMAND test1
      COMMANDS+=("test1")

      shift_arg
      APPSPEC.parse-help-test1

      return
    ;;
    *)
      debug "UNKNOWN cmd ${argv[0]}"
      ERRORS+=("unknown subcommand ${argv[0]}")
      shift_arg
      return
    ;;


    esac
  done

}

APPSPEC.parse-nested1-nested2() {
  while [[ ${#argv} > 0 ]]; do
    case "${argv[0]}" in

    -*)

    ;;

    # SUBCOMMANDS

    esac
  done

}

APPSPEC.parse-nested1() {
  while [[ ${#argv} > 0 ]]; do
    case "${argv[0]}" in

    -*)

    ;;

    # SUBCOMMANDS
    nested2)
      debug COMMAND nested2
      COMMANDS+=("nested2")

      shift_arg
      APPSPEC.parse-nested1-nested2
                if [[ -z "$OP" ]]; then
                  OP=nested2
                  APPSPEC.run-op
                fi

      return
    ;;
    *)
      debug "UNKNOWN cmd ${argv[0]}"
      ERRORS+=("unknown subcommand ${argv[0]}")
      shift_arg
      return
    ;;


    esac
  done

}

APPSPEC.parse-test1() {
  while [[ ${#argv} > 0 ]]; do
    case "${argv[0]}" in
    --flag-a)
        debug "LONG OPTION flag-a"
        OPT_FLAG_A=true
        shift_arg

    ;;
    --flag-b)
        debug "LONG OPTION flag-b"
        OPT_FLAG_B=true
        shift_arg

    ;;
    --flag-c)
        debug "LONG OPTION flag-c"
        OPT_FLAG_C+=1
        shift_arg

    ;;
    --test-d)
        debug "LONG OPTION test-d"
        shift_arg
        OPT_TEST_D="${argv[0]}"
        shift_arg

    ;;
    --test-e)
        debug "LONG OPTION test-e"
        shift_arg
        OPT_TEST_E="${argv[0]}"
        shift_arg

    ;;
    --test-f)
        debug "LONG OPTION test-f"
        shift_arg
        OPT_TEST_F+=("${argv[0]}")
        shift_arg

    ;;
    --test-g)
        debug "LONG OPTION test-g"
        shift_arg
        OPT_TEST_G="${argv[0]}"
        shift_arg

    ;;
    --*)
        debug "!UNKNOWN OPTION ${argv[0]}"
        ERRORS+=("unknown option ${argv[0]}")
        shift_arg
        break
    ;;

    -*)
      local i arg=${argv[0]/-/}
      for (( i=0; i < "${#arg}"; i++ )); do
        local char="${arg:$i:1}"
        value="${arg:$i+1}"
        if (( $i+1 == ${#arg} )); then
          shift_arg
          value="${argv[0]}"
        fi
        debug "processing short $char. arg=$arg value=$value"
        case "$char" in
        a)
          debug "SHORT OPTION flag-a"
          OPT_FLAG_A=true

        ;;
        b)
          debug "SHORT OPTION flag-b"
          OPT_FLAG_B=true

        ;;
        c)
          debug "SHORT OPTION flag-c"
          OPT_FLAG_C+=1

        ;;
        d)
          debug "SHORT OPTION test-d"
          OPT_TEST_D="$value"
          shift_arg
          break

        ;;
        e)
          debug "SHORT OPTION test-e"
          OPT_TEST_E="$value"
          shift_arg
          break

        ;;
        f)
          debug "SHORT OPTION test-f"
          OPT_TEST_F+=("$value")
          shift_arg
          break

        ;;
        g)
          debug "SHORT OPTION test-g"
          OPT_TEST_G="$value"
          shift_arg
          break

        ;;
        *)
          debug "!UNKNOWN option -$char"
          ERRORS+=("unknown option -$char")
          shift_arg
          break
        ;;
        esac
      done

    ;;

    # SUBCOMMANDS

    esac
  done

}



APPSPEC.cmd_help() {
  echo help
  source "$APPSPECDIR/lib/help"
  COMMANDS=("${COMMANDS[@]:1}")
  if [[ -n "$COMMANDS" ]]; then
    local func="${COMMANDS[*]}"
    func="${func/ /-}"
    APPSPEC.help-$func
  else
    APPSPEC.help
  fi
}

shift_arg() {
    argv=("${argv[@]:1}")
}

debug() {
  $DEBUG && echo $@
}
